#!/usr/bin/env python3

import ast
import os
import shutil
import socket
import subprocess
import sys
import tempfile
import time
from pathlib import Path

KLEE_IMAGE = os.environ.get("KLEE_IMAGE", "klee/klee")
KLEE_MAX_TIME = os.environ.get("KLEE_MAX_TIME", "300s")

INPUT_LEN = 24
TARGET_X = [
    0x14, 0xC5, 0x73, 0xB6, 0x42, 0xF1, 0xC6, 0xA4,
    0x10, 0xC1, 0x86, 0xA9, 0x29, 0xAF, 0x05, 0x18,
    0xC4, 0xDE, 0x47, 0x13, 0x09, 0x03, 0xCD, 0x4D,
]
TARGET_ST16 = [0xB51A, 0x8C24, 0x9FD9, 0x8EF2]
FINAL_ST = 0x0F948EF2


def rotl8(x: int, r: int) -> int:
    r &= 7
    return ((x << r) & 0xFF) | (x >> (8 - r) if r else 0)


def rotr8(x: int, r: int) -> int:
    r &= 7
    return (x >> r) | (((x << (8 - r)) & 0xFF) if r else 0)


def validate_py(s: bytes) -> bool:
    if len(s) != INPUT_LEN:
        return False

    st = 0xC0FFEE13
    for i in range(INPUT_LEN):
        a = s[i]
        if a < 0x21 or a > 0x7E:
            return False

        b = s[(i + 7) % INPUT_LEN]
        c = s[(i + 13) % INPUT_LEN]

        x = a ^ ((0xA5 + 11 * i) & 0xFF)
        x = (x + rotl8(b, i)) & 0xFF
        x ^= rotr8(c, i + 3)
        x = (x * ((0x3D ^ (7 * i)) & 0xFF)) & 0xFF
        x ^= (st >> ((i & 3) * 8)) & 0xFF

        st = (st + 0x9E3779B9) & 0xFFFFFFFF
        st ^= (x * 0x45D9F3B) & 0xFFFFFFFF
        st ^= (st >> 16)

        if x != TARGET_X[i]:
            return False

        if (i % 6) == 5:
            if (st & 0xFFFF) != TARGET_ST16[i // 6]:
                return False

    return (st & 0xFFFFFFFF) == FINAL_ST


class BufferedSocket:
    def __init__(self, sock: socket.socket):
        self.sock = sock
        self.buf = b""

    def _fill(self) -> None:
        chunk = self.sock.recv(4096)
        if not chunk:
            raise EOFError("Connection closed")
        self.buf += chunk

    def recv_until(self, needle: bytes, max_bytes: int = 1_000_000) -> bytes:
        while needle not in self.buf:
            self._fill()
            if len(self.buf) > max_bytes:
                raise ValueError("Too much data received while waiting for prompt")
        idx = self.buf.index(needle) + len(needle)
        out = self.buf[:idx]
        self.buf = self.buf[idx:]
        return out


def run_checked(cmd: list[str]) -> str:
    try:
        p = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            check=True,
        )
    except FileNotFoundError as e:
        raise SystemExit(f"Missing dependency: {e.filename}")
    except subprocess.CalledProcessError as e:
        raise SystemExit(
            f"Command failed ({e.returncode}): {' '.join(cmd)}\n\n" + (e.stdout or "")
        )
    return p.stdout


def extract_symbolic_input(ktest_output: str) -> bytes:
    cur_name = None
    for ln in ktest_output.splitlines():
        ln = ln.strip()
        if ": name:" in ln:
            cur_name = ln.split(": name:", 1)[1].strip()
        elif ": data:" in ln:
            lit = ln.split(": data:", 1)[1].strip()
            try:
                b = ast.literal_eval(lit)
            except Exception:
                continue
            if isinstance(b, (bytes, bytearray)):
                b = bytes(b)
                if cur_name is not None and "'in'" in cur_name and len(b) == 24:
                    return b

    # Fallback: first 24-byte data blob.
    for ln in ktest_output.splitlines():
        ln = ln.strip()
        if ": data:" in ln:
            lit = ln.split(": data:", 1)[1].strip()
            try:
                b = ast.literal_eval(lit)
            except Exception:
                continue
            if isinstance(b, (bytes, bytearray)) and len(b) == 24:
                return bytes(b)

    raise SystemExit("Failed to extract a 24-byte input from ktest-tool output")


def derive_solution_with_klee() -> bytes:
    writeup_dir = Path(__file__).resolve().parent
    challenge_dir = writeup_dir.parent
    src_dir = challenge_dir / "src"

    thathing_c = src_dir / "thathing.c"
    harness_c = writeup_dir / "klee_harness.c"

    if not thathing_c.exists():
        raise SystemExit(f"Missing source file: {thathing_c}")
    if not harness_c.exists():
        raise SystemExit(f"Missing harness file: {harness_c}")

    with tempfile.TemporaryDirectory(prefix="thathing-klee-") as td:
        td_path = Path(td)
        shutil.copy2(thathing_c, td_path / "thathing.c")
        shutil.copy2(harness_c, td_path / "klee_harness.c")

        klee_script = (
            "set -euo pipefail; "
            "clang -emit-llvm -c -DTHATHING_NO_MAIN thathing.c -o thathing.bc; "
            "clang -emit-llvm -c klee_harness.c -o harness.bc; "
            "llvm-link thathing.bc harness.bc -o linked.bc; "
            f"klee -max-time={KLEE_MAX_TIME} linked.bc"
        )

        run_checked(
            [
                "docker",
                "run",
                "--rm",
                "-v",
                f"{td}:/work",
                "-w",
                "/work",
                KLEE_IMAGE,
                "bash",
                "-lc",
                klee_script,
            ]
        )

        dump = run_checked(
            [
                "docker",
                "run",
                "--rm",
                "-v",
                f"{td}:/work",
                "-w",
                "/work",
                KLEE_IMAGE,
                "bash",
                "-lc",
                "for k in klee-last/*.ktest; do echo KTEST:$k; ktest-tool $k; echo ENDKTEST; done",
            ]
        )

        cases = []
        cur = None
        cur_lines = []
        for ln in dump.splitlines():
            if ln.startswith("KTEST:"):
                cur = ln[len("KTEST:") :].strip()
                cur_lines = []
            elif ln.strip() == "ENDKTEST":
                if cur is not None:
                    cases.append(extract_symbolic_input("\n".join(cur_lines)))
                cur = None
                cur_lines = []
            else:
                if cur is not None:
                    cur_lines.append(ln)

        for b in cases:
            if validate_py(b):
                return b

        raise SystemExit("KLEE did not produce a satisfying testcase (try increasing KLEE_MAX_TIME).")


def main() -> int:
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} HOST PORT", file=sys.stderr)
        return 2

    host = sys.argv[1]
    port = int(sys.argv[2])

    solution = derive_solution_with_klee()

    # Print derived solution so it's obvious KLEE produced it.
    try:
        print(solution.decode("ascii"), file=sys.stderr)
    except UnicodeDecodeError:
        print(repr(solution), file=sys.stderr)

    last_err = None
    for _ in range(30):
        try:
            with socket.create_connection((host, port), timeout=2.0) as sock:
                sock.settimeout(2.0)
                bs = BufferedSocket(sock)
                bs.recv_until(b"Input (24 chars): ")
                sock.sendall(solution + b"\n")

                out = b""
                while True:
                    try:
                        chunk = sock.recv(4096)
                    except socket.timeout:
                        break
                    if not chunk:
                        break
                    out += chunk

                sys.stdout.buffer.write(out)
                return 0
        except (OSError, EOFError, ValueError) as e:
            last_err = e
            time.sleep(0.1)

    raise SystemExit(f"Failed to talk to service after retries: {last_err}")


if __name__ == "__main__":
    raise SystemExit(main())
