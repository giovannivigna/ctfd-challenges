#!/usr/bin/env python3
import base64
import socket
import sys
from elftools.elf.elffile import ELFFile


def recv_until(sock: socket.socket, needle: bytes, limit: int = 1_000_000) -> bytes:
    buf = b""
    while needle not in buf:
        chunk = sock.recv(4096)
        if not chunk:
            break
        buf += chunk
        if len(buf) > limit:
            raise RuntimeError("recv limit hit")
    return buf


def main() -> int:
    if len(sys.argv) != 3:
        print(f"usage: {sys.argv[0]} HOST PORT", file=sys.stderr)
        return 2
    host, port = sys.argv[1], int(sys.argv[2])

    s = socket.create_connection((host, port))
    recv_until(s, b"> ")
    s.sendall(b"2\n")  # run sample

    recv_until(s, b"> ")
    s.sendall(b"/proc/self/exe\n")

    # The sample prints base64 now; read until the next prompt.
    data = recv_until(s, b"\n> ", limit=8_000_000)
    # strip the trailing prompt
    data = data.rsplit(b"\n> ", 1)[0]
    b64 = b"".join(data.split())

    elf_bytes = base64.b64decode(b64, validate=True)

    # Parse and extract .cinfra.contents
    import io

    ef = ELFFile(io.BytesIO(elf_bytes))
    sec = ef.get_section_by_name(".cinfra.contents")
    if sec is None:
        raise RuntimeError("missing .cinfra.contents in dumped sample")
    raw = sec.data().rstrip(b"\x00")
    print(raw.decode(errors="replace"))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

