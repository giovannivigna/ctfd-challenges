#!/usr/bin/env python3

import sys
import binascii
import socket
import time


KEY = b"SuperSecretKey"


def xor_decrypt(ciphertext: bytes, key: bytes) -> bytes:
    return bytes(b ^ key[i % len(key)] for i, b in enumerate(ciphertext))

class BufferedSocket:
    def __init__(self, sock: socket.socket):
        self.sock = sock
        self.buf = b""

    def _fill(self) -> None:
        chunk = self.sock.recv(4096)
        if not chunk:
            raise EOFError("Connection closed")
        self.buf += chunk

    def recv_until(self, needle: bytes, max_bytes: int = 1_000_000) -> bytes:
        while needle not in self.buf:
            self._fill()
            if len(self.buf) > max_bytes:
                raise ValueError("Too much data received while waiting for prompt")
        idx = self.buf.index(needle) + len(needle)
        out = self.buf[:idx]
        self.buf = self.buf[idx:]
        return out

    def recv_line(self, max_bytes: int = 1_000_000) -> bytes:
        while b"\n" not in self.buf:
            self._fill()
            if len(self.buf) > max_bytes:
                raise ValueError("Too much data received while waiting for line")
        idx = self.buf.index(b"\n") + 1
        out = self.buf[:idx]
        self.buf = self.buf[idx:]
        return out


def main() -> int:
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} HOST PORT", file=sys.stderr)
        return 2

    host = sys.argv[1]
    port = int(sys.argv[2])

    # The service runs under xinetd inside a container; right after startup it may
    # accept and close connections briefly. Retry a few times to be robust.
    last_err: Exception | None = None
    for _ in range(30):
        try:
            with socket.create_connection((host, port), timeout=2.0) as sock:
                sock.settimeout(2.0)
                bs = BufferedSocket(sock)

                bs.recv_until(b"Encrypted secret (hex): ")
                secret_hex = bs.recv_line().strip()
                ciphertext = binascii.unhexlify(secret_hex)
                plaintext = xor_decrypt(ciphertext, KEY)

                bs.recv_until(b"Enter the secret: ")
                sock.sendall(plaintext + b"\n")

                # Read the rest (flag or failure message).
                out = b""
                while True:
                    try:
                        chunk = sock.recv(4096)
                    except socket.timeout:
                        break
                    if not chunk:
                        break
                    out += chunk
                sys.stdout.buffer.write(out)
                return 0
        except (OSError, EOFError, ValueError) as e:
            last_err = e
            time.sleep(0.1)

    raise SystemExit(f"Failed to talk to service after retries: {last_err}")


if __name__ == "__main__":
    raise SystemExit(main())

