#!/usr/bin/env python3
import os
import re
import sys
import tempfile
from typing import Optional, Tuple

from pwn import context, remote  # type: ignore

from elftools.elf.elffile import ELFFile
from elftools.elf.sections import SymbolTableSection

def _vaddr_to_offset(elf: ELFFile, vaddr: int) -> Optional[int]:
    for seg in elf.iter_segments():
        if seg["p_type"] != "PT_LOAD":
            continue
        start = int(seg["p_vaddr"])
        end = start + int(seg["p_memsz"])
        if start <= vaddr < end:
            return int(seg["p_offset"]) + (vaddr - start)
    return None


def extract_answers(elf_path: str) -> Tuple[int, int, str, int]:
    with open(elf_path, "rb") as f:
        elf = ELFFile(f)

        # Q1: text segment address (same logic as server)
        text_addr = None
        for seg in elf.iter_segments():
            if seg["p_type"] == "PT_LOAD" and (int(seg["p_flags"]) & 0x1):
                text_addr = int(seg["p_vaddr"])
                break
        if text_addr is None:
            raise RuntimeError("failed to locate executable PT_LOAD segment")

        # Q2: total size of writable SHT_PROGBITS sections (same logic as server)
        data_size = 0
        writable_progbits_blobs: list[bytes] = []
        for sec in elf.iter_sections():
            if sec["sh_type"] == "SHT_PROGBITS" and (int(sec["sh_flags"]) & 0x2):
                data_size += int(sec["sh_size"])
                try:
                    writable_progbits_blobs.append(sec.data())
                except Exception:
                    pass

        # Q4: main function address
        main_addr = None
        for sec in elf.iter_sections():
            if isinstance(sec, SymbolTableSection):
                for sym in sec.iter_symbols():
                    if sym.name == "main":
                        main_addr = int(sym["st_value"])
                        break
            if main_addr is not None:
                break
        if main_addr is None:
            raise RuntimeError("failed to locate main symbol")

        # Q3: secret password (prefer secret symbol if present)
        secret = None
        secret_vaddr = None
        for sec in elf.iter_sections():
            if isinstance(sec, SymbolTableSection):
                for sym in sec.iter_symbols():
                    if sym.name == "secret":
                        secret_vaddr = int(sym["st_value"])
                        break
            if secret_vaddr is not None:
                break

        if secret_vaddr is not None:
            off = _vaddr_to_offset(elf, secret_vaddr)
            if off is not None:
                f.seek(off)
                s = bytearray()
                for _ in range(256):
                    b = f.read(1)
                    if not b or b == b"\x00":
                        break
                    s += b
                try:
                    candidate = s.decode("ascii", errors="strict")
                    if re.fullmatch(r"[A-Za-z0-9]{16}", candidate):
                        secret = candidate
                except Exception:
                    pass

        if secret is None:
            # Fallback: scan writable progbits payloads for 16-char alnum C-string
            pat = re.compile(rb"([A-Za-z0-9]{16})\x00")
            for blob in writable_progbits_blobs:
                m = pat.search(blob)
                if m:
                    secret = m.group(1).decode("ascii")
                    break

        if secret is None:
            raise RuntimeError("failed to recover secret string")

        return text_addr, data_size, secret, main_addr


def main(argv: list[str]) -> int:
    if len(argv) != 3:
        print(f"Usage: {argv[0]} HOST PORT", file=sys.stderr)
        return 2

    host = argv[1]
    port = int(argv[2])

    context.log_level = "error"
    io = remote(host, port, timeout=10)
    try:
        line = io.recvline(keepends=True)
        m = re.match(rb"Binary length:\s*(\d+)\s*\n", line)
        if not m:
            raise RuntimeError(f"unexpected banner line: {line!r}")
        n = int(m.group(1))

        binary = io.recvn(n)

        with tempfile.TemporaryDirectory() as td:
            elf_path = os.path.join(td, "esrever.bin")
            with open(elf_path, "wb") as f:
                f.write(binary)

            text_addr, data_size, secret, main_addr = extract_answers(elf_path)

        # Print derived answers before using them.
        # (stderr so stdout can remain "flag-only" if desired)
        print(f"[+] text segment vaddr: 0x{text_addr:x}", file=sys.stderr)
        print(f"[+] writable SHT_PROGBITS total size: {data_size}", file=sys.stderr)
        print(f"[+] secret password: {secret}", file=sys.stderr)
        print(f"[+] main() address: 0x{main_addr:x}", file=sys.stderr)

        io.sendlineafter(b"Question 1:", f"0x{text_addr:x}".encode())
        io.sendlineafter(b"Question 2:", str(data_size).encode())
        io.sendlineafter(b"Question 3:", secret.encode())
        io.sendlineafter(b"Question 4:", f"0x{main_addr:x}".encode())

        out = io.recvall(timeout=2)

        m = re.search(rb"(ictf\{[^}\n]+\})", out)
        if m:
            sys.stdout.write(m.group(1).decode("ascii") + "\n")
            return 0

        # Fallback: print whatever we got (best-effort)
        sys.stdout.write(out.decode("utf-8", errors="replace"))
        if out and not out.endswith(b"\n"):
            sys.stdout.write("\n")
        return 1
    finally:
        try:
            io.close()
        except Exception:
            pass


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))

