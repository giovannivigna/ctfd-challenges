#!/usr/bin/env python3
import os
import ipaddress
import socket
import sys
import time


def main():
    if len(sys.argv) != 4:
        print(f"Usage: {sys.argv[0]} <host> <port> <file>")
        sys.exit(1)

    host = sys.argv[1]
    port = int(sys.argv[2])
    file_path = sys.argv[3]

    if not os.path.isfile(file_path):
        print(f"[!] File not found: {file_path}")
        sys.exit(1)

    with open(file_path, "rb") as f:
        payload = f.read()

    def candidates(h: str) -> list[str]:
        try:
            ip = ipaddress.ip_address(h)
        except ValueError:
            return [h]
        if isinstance(ip, ipaddress.IPv4Address):
            # Some deployments expose the service via an IPv6 listener only;
            # IPv4-mapped IPv6 works in that case.
            return [h, f"::ffff:{h}"]
        return [h]

    last_err: Exception | None = None
    for h in candidates(host):
        backoff_s = 0.1
        for _attempt in range(8):
            try:
                with socket.create_connection((h, port), timeout=5) as s:
                    s.settimeout(5)

                    def recv_until(needle: bytes, max_bytes: int = 1_000_000) -> bytes:
                        buf = bytearray()
                        while needle not in buf:
                            chunk = s.recv(4096)
                            if not chunk:
                                break
                            buf += chunk
                            if len(buf) > max_bytes:
                                raise RuntimeError("Too much data while waiting for prompt")
                        return bytes(buf)

                    banner = recv_until(b"Enter your payload length:")
                    if b"Enter your payload length:" not in banner:
                        raise ConnectionError("Service closed before prompt")

                    s.sendall(f"{len(payload)}\n".encode())
                    recv_until(b"Enter your payload:")
                    s.sendall(payload)

                    # Read remaining output until the service closes the connection.
                    out = bytearray()
                    while True:
                        try:
                            chunk = s.recv(4096)
                        except socket.timeout:
                            time.sleep(0.1)
                            try:
                                chunk = s.recv(4096)
                            except socket.timeout:
                                break
                        if not chunk:
                            break
                        out += chunk

                    print(out.decode(errors="ignore"))
                    return
            except Exception as e:
                last_err = e
                time.sleep(backoff_s)
                backoff_s = min(backoff_s * 1.7, 1.0)
                continue

    raise SystemExit(f"[!] Exploit failed to connect/send payload: {last_err}")


if __name__ == "__main__":
    main()

