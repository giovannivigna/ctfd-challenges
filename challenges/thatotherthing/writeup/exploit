#!/usr/bin/env python3

import os
import sys

import angr
import claripy
from pwn import remote

INPUT_LEN = 32
RET_ADDR = 0xDEADBEEF


def solve(binary_path: str) -> bytes:
    proj = angr.Project(binary_path, auto_load_libs=False)

    sym = proj.loader.find_symbol("validate")
    if sym is None:
        raise RuntimeError("Could not find symbol 'validate' (is the binary stripped?)")
    validate_addr = sym.rebased_addr

    buf = claripy.BVS("buf", INPUT_LEN * 8)
    buf_addr = 0x500000

    state = proj.factory.call_state(validate_addr, buf_addr, INPUT_LEN, ret_addr=RET_ADDR)
    state.memory.store(buf_addr, buf)

    for i in range(INPUT_LEN):
        b = buf.get_byte(i)
        state.solver.add(b >= 0x21)
        state.solver.add(b <= 0x7E)

    simgr = proj.factory.simgr(state)
    simgr.explore(find=RET_ADDR)
    if not simgr.found:
        raise RuntimeError("No state reached the function return address")

    found = simgr.found[0]
    found.solver.add(found.regs.rax == 1)
    if not found.solver.satisfiable():
        raise RuntimeError("Reached return, but return value cannot be 1")

    return found.solver.eval(buf, cast_to=bytes)


def main() -> None:
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <host> <port> [binary_path]")
        sys.exit(1)

    host = sys.argv[1]
    port = int(sys.argv[2])

    binary_path = sys.argv[3] if len(sys.argv) > 3 else "./thatotherthing"
    if not os.path.exists(binary_path):
        print(f"[-] Binary not found: {binary_path}")
        sys.exit(1)

    print(f"[*] Solving {binary_path} with angr...")
    sol = solve(binary_path)
    print(f"[*] Solution: {sol!r}")

    print(f"[*] Connecting to {host}:{port} ...")
    io = remote(host, port)
    io.recvuntil(b"Input", timeout=3)
    io.sendline(sol)
    out = io.recvall(timeout=3)
    try:
        print(out.decode(errors="replace"))
    finally:
        io.close()


if __name__ == "__main__":
    main()

